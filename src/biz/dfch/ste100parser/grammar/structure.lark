// Copyright (C) 2026 Ronald Rink, d-fens GmbH, http://d-fens.ch
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as published
// by the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Affero General Public License for more details.
//
// You should have received a copy of the GNU Affero General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.

// grammar.lark
// Inline markup grammar (strict; preserves whitespace; multiline quotes allowed)

?start: inline*

// ---------- Top-level inline stream ----------
?inline: WS
       | NEWLINE
       | code
       | bold_emph
       | bold
       | emph
       | dquote
       | squote
       | cite
       | TEXT
       | MULTIPLY
       | APOSTROPHE
       | PLURAL_S
       | YEAR_SHORT

// ---------- Containers ----------
dquote: DQUOTE dquote_item* DQUOTE
?dquote_item: WS
            // | NEWLINE
            | code
            | bold_emph
            | bold
            | emph
            | squote      // allow '...' inside "..."
            | MULTIPLY
            | TEXT
            | APOSTROPHE
            | PLURAL_S
            | YEAR_SHORT

squote: SQUOTE squote_item* SQUOTE
?squote_item: WS
            // | NEWLINE
            | code
            | bold_emph
            | bold
            | emph
            | dquote      // allow "..." inside '...'
            | MULTIPLY
            | TEXT
            | APOSTROPHE
            | PLURAL_S
            | YEAR_SHORT

bold: STAR_OPEN bold_item+ STAR_CLOSE
?bold_item: WS
          | code
          | emph         // bold can contain emphasis
          | dquote
          | squote
          | MULTIPLY
          | TEXT
          | APOSTROPHE
          | PLURAL_S
          | YEAR_SHORT

emph: UNDER_OPEN emph_item+ UNDER_CLOSE
?emph_item: WS
          | code
          | bold         // emphasis can contain bold
          | dquote
          | squote
          | MULTIPLY
          | TEXT
          | APOSTROPHE
          | PLURAL_S
          | YEAR_SHORT

bold_emph: BOLD_EMPH_OPEN bold_emph_item* BOLD_EMPH_CLOSE
?bold_emph_item: WS
               | code
               | dquote
               | squote
               | MULTIPLY
               | TEXT
               | APOSTROPHE
               | PLURAL_S
               | YEAR_SHORT

cite: NEWLINE CITE_BLOCK cite_item* NEWLINE
?cite_item: WS
               | bold
               | emph
               | bold_emph
               | dquote
               | squote
               | MULTIPLY
               | TEXT
               | APOSTROPHE
               | PLURAL_S
               | YEAR_SHORT

// ---------- Code (literal until ending backtick) ----------
code: BACK_TICK CODE BACK_TICK

// ---------- Terminals ----------
// Highest priority: code and year abbreviations
CODE.40: /[^`]+/
YEAR_SHORT.40: /'\d{2}s?(?=[\s.,!?;:]|$)/

// Plural (s) - Matches (s) if preceded by a letter  
// and followed by space, punctuation, or end of string.  
// We use a lookbehind for a letter [A-Za-z]  
PLURAL_S.35: /(?<=[A-Za-z])\(s\)(?=[\s.,!?;:]|$)/

// Apostrophes (possessives, decades like 1990's)
// Matches ' or 's if preceded by alphanumeric
// and followed by space, punctuation, or end of string
APOSTROPHE.30: /(?<=[A-Za-z0-9])'(?:s)?(?=[\s.,!?;:]|$)/

// Make "*_" and "_*" single tokens so they don't split into STAR/UNDER
BOLD_EMPH_OPEN.10: "*_"
BOLD_EMPH_CLOSE.10: "_*"

CITE_BLOCK.10: "> "

// Delimiter tokens
DQUOTE: "\""
SQUOTE: "'"
MULTIPLY: " * "
STAR: "*"
STAR_OPEN.2: /\*(?!\s)/
STAR_CLOSE.2: /(?<!\s)\*/

UNDER: "_"
UNDER_OPEN.2: /_(?!\s)/
UNDER_CLOSE.2: /(?<!\s)_/

BACK_TICK: "`"

// Whitespace preserved.
// When there is more than one WS, then this is only one token.
WS: /[ \t]+/
// When there is more than on NEWLINE, then each NEWLINE is a different token.
NEWLINE: /\r?\n/

// Any run of characters that is not a delimiter or whitespace/newline
TEXT: /[^"'*_`\s]+/
// TEXT: /[a-zA-Z0-9\(\).,:?!=-]+/

TEXT_NO_UNDER: /[^"'*`\s]+/